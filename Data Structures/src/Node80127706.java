import java.util.ArrayList;//Εισαγωγή της util για χρήση του ArrayList


public class Node80127706  //Δημιουγία κλάσσης Node80127706 
{
  // TODO Rename and fill the code
	Node80127706 parent; // Δήλωση αντικειμένου parent
	ArrayList<Node80127706>children = new ArrayList<Node80127706>(); //Δήλωση Arraylist
	int flag; //Δήλωση flag  που χρησιμοποιείται για τα παιδιά ενός κόμβου
	int nodeDepth; //Δήλωση nodeDepth που χρησιμοποιείται για το βάθος ενός κόμβου
	int []nodeMove; //Πίνακας nodeMove που αποθηκεύει την κίνηση που αντιστοιχεί στο εκάστωτε αντικείμενο 
	Board nodeBoard;//Μεταβλητή τύπου Board που μας δίνει την τρέχουσα κατάσταση του ταμπλό για την κάθε κίνηση
	double nodeEvaluation;  // Μεταβλητή double  που μας δίνει το value κάθε αντικειμένου
	
	
	public Node80127706(){ // Δήλωση κενού constructor 
		parent = null; // Εκχώρηση τιμών στις μεταβλητές του node80127706
		nodeDepth = 0;
		nodeMove = new int [2];
		nodeBoard = null;
		nodeEvaluation = 0;
		flag = 0;
	}
	
	public Node80127706(Node80127706 parent,int nodeDepth,Board nodeBoard,double nodeEvaluation){ // Δήλωση contrusctor με ορίσματα
		this.parent = parent; //Εκχώρηση τιμών στις μεταβλητές 
		this.nodeDepth = nodeDepth;
		this.nodeMove = new int [2]; 
		this.nodeBoard = nodeBoard;
		this.nodeEvaluation = nodeEvaluation;
		flag = 0;
	}
	//Setters and getters
	public void setParent(Node80127706 parent){ //Θέτουμε τιμές για την μεταβλητή  parent
		this.parent = parent;
	}
	public void setChildren (Node80127706 node){ //Δέσμευση χώρου και πρόσθεση  νέου αντικειμένου στη λίστα
		children.add(node);
		flag++; // Αύξηση της μεταβλητής flag  που χρησιμοποιείται για το πλήθος των παιδιών κάθε κόμβου  
	}
	public void  setNodeDepth (int nodeDepth){ //Θέτουμε τιμή στην μεταβλητή nodeDepth
		this.nodeDepth = nodeDepth;
	}
	public void setNodeMove (int x ,int y){ //Θέτουμε τιμές στον πίνακα nodeMove
		nodeMove[0]=x;//Εκχώρηση τιμών στον πίνακα(συντεταγμένες)
		nodeMove[1]=y;
	}
	public void setNodeBoard(Board nodeBoard){//Ορίζουμε τον πίνακα που χρησιμοποιούμε για αυτό το αντικείμενο
		this.nodeBoard = nodeBoard;
	}
	public void setNodeEvaluation(double nodeEvaluation){//Εκχώρηση τιμής-value στην nodeEvaluation
		this.nodeEvaluation = nodeEvaluation;
	}
	public Node80127706 getParent(){//Επιστροφή του αντικειμένου parent
		return parent;
	}
	public Node80127706 getChildren(int n){//Επιστροφή ενός αντικειμένου τύπου Node80127706 που είναι αποθηκευμένο στην ArrayList children 
		return children.get(n);
	}
	public int getNodeDepth(){//Επιστροφή της μεταβλητής nodeDepth
		return nodeDepth;
	}
	public int []getNodeMove(){//Επιστροφή του πίνακα nodeMove
		return nodeMove;
	}
	public Board getNodeBoard(){//Επιστροφή της μεταβλητής που είναι αποθηκευμένο το board
		return nodeBoard;
	}
	public double getNodeEvaluation(){//Επιστροφή της μεταβλητής nodeEvaluation
		return nodeEvaluation;
	}
	public int getFlag(){//Επιστροφή της μεταβλητής flag
		return flag;
	}
	
	
	
	
	
	double evaluate (int x, int y, Board board,int Id,int [][]weight){
	  	  // TODO
		  
		  int valueCombo,valueCentrality,valueHorizontal,valueVertical,valueDiagonal1,valueDiagonal2;//Δήλωση μεταβλητών στις οποίες θα αποθηκευτούν τα οριζόντια,τα κάθετα και τα 2 είδη διαγωνίων value.Καθώς και το centrality και το συνολικό value.
		  valueHorizontal = checkHorizontalValue(x,y,board,Id);//Κλήση της συνάρτησης checkHorizontalValue και εκχώρηση της τιμής της.
		  valueVertical = checkVerticalValue(x,y,board,Id);//Κλήση της συνάρτησης checkVerticalValue και εκχώρηση της τιμής της.
		  valueDiagonal1 = checkDiagonalValue1(x,y,board,Id);//Κλήση της συνάρτησης checkDiagonalValue1 και εκχώρηση της τιμής της.
		  valueDiagonal2 = checkDiagonalValue2(x,y,board,Id);//Κλήση της συνάρτησης checkDiagonalValue2 και εκχώρηση της τιμής της.
		  valueCentrality = weight[x][y];//Κλήση της συνάρτησης getWeight και εκχώρηση της τιμής της.
		  //Έλεγχος για εύρεση πεντάδας προς όλες τις κατευθύνσεις ώστε να επιστραφεί απευθείας η μέγιστη επιτρεπτή τιμή.
		  if((valueHorizontal == 100)||(valueVertical == 100)||(valueDiagonal1 == 100)||(valueDiagonal2 == 100)){
			  return 400;//Επιστροφή μέγιστης τιμής(0-400 κλίμακα)
		  }
		  
		  valueCombo = valueHorizontal + valueVertical + valueDiagonal1 + valueDiagonal2;//Εκχώρηση αθροίσματος συνολικού value(κατευθύνσεων)
		  return (valueCombo + valueCentrality);//Επιστροφή value αθροίσματος κατευθύνσεων και κεντρικότητας
	  }
	  /*Δήλωση και Υλοποίηση της συνάρτησης checkHorizontalValue
	   * Υπολογίζει το value των συνδυασμών που γίνονται οριζόντια π.χ οριζόντια τετράδα,τριάδα κλπ. λαμβάνοντας υπόψη
	   *  τα όρια του πίνακα.
	   * 
	   * 
	   * 
	   * 
	   * 
	   * */
	  int checkHorizontalValue(int x,int y,Board board,int Id){
		  int valueHorizontal = 0;//Δήλωση μεταβλητής που θα έχει το value των οριζόντιων συνδυασμών
		  int horizontalLeft=0,horizontalRight=0;//Δήλωση μεταβλητής με την μορφή flag που υποδηλώνει την ύπαρξη κελιού αντίθετου χρώματος από του Id που του αποκλείει την δυνατότητα συνέχισης συνδυασμού από μια πλευρά.
		  int numHorizontalRight=0,numHorizontalLeft = 0,numHorizontal = 0;//Αθροιστής συνεχόμενων κελιών του χρώματος του Id δεξιά και αριστερά καθώς και ολικά. 
		  int signLeft=100,signRight =100;//Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση του πλησιέστερου κελιού με αντίθετο χρώμα από το κελί που εξετάζουμε.Αντίστοιχα μία από την δεξιά μεριά και μία από την αριστερή.
		  int sizeLeft = 0, sizeRight = 0;//Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση των ορίων του ταμπλό από το κελί που εξετάζουμε.
		  int i = 1;//Δήλωση μίας μεταβλητής που χρησιμεύει στις επαναλήψεις
		  
		  while((i <= 4)&&(i <= x)){//Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε αριστερά από την ευθεία x=0 και να ελέγξουμε μέγιστα 4 κελιά αριστερά από την θέση που εξετάζουμε(π.χ άμα είμαστε στην θέση 2,3 θα μπει 2 φορές στην επανάληψη επειδή βρίσκει δύο κουτιά μέχρι το όριο.)   
		    	//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
			  sizeLeft++;//Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeLeft πόση επιτρεπτή απόσταση έχουμε από αριστερά.
			  i++;
		    }
		  
		  i = 1;//Αρχικοποίηση της μεταβλητής i
		  
		  while((i <= 4)&&(i <= GomokuUtilities.NUMBER_OF_COLUMNS - x - 1)){//Αντίστοιχη διαδικασία με το sizeLeft από δεξιά απλά με όριο την x=14.
		    	sizeRight++;
		    	i++;
		  }
		    
		  i = 1;//Αρχικοποίηση της μεταβλητής i
		  
		  while(i <= sizeLeft){//Επανάληψη που γίνεται μέγιστο sizeLeft φορές.
			  if(Id == board.getTile(x-i,y).getColor()){//Έλεγχος άμα το κελί που είναι αριστερά από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
				  numHorizontalLeft++;//Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας από τα αριστερά.
			  }else if(board.getTile(x-i,y).getColor() == 0){//Έλεγχος άμα το κελί που είναι αριστερά από αυτό που ελέγχουμε έχει γκρι χρώμα.
				  i = 5;//Σε περίπτωση γκρι χρώματος αυξάνουμε τον μετρητή σε μη επιτρεπτή τιμή ώστε να βγει από την επανάληψη,αφού σπάει το σερί του χρώματος μας.
			  }else{//Έλεγχος ύπαρξης αντίθετου χρώματος αριστερά από το κελί που ελέγχουμε.
				  if (numHorizontalLeft!=0){//Έλεγχος άμα ο αριθμός συνεχόμενων κελιών του ίδιου χρώματος με το χρώμα του παίκτη μας είναι μεγαλύτερο-διάφορο του μηδενός.
					  //Ο έλεγχος αυτός γίνεται για να δούμε αμα το ακριβώς αριστερά μας κελί είναι αντίθετου χρώματος.Και ουσιαστικά μας αποκλείει την δυνατότητα συνέχισης συνδυασμού από την αριστερή πλευρά.
					  horizontalLeft=1;//flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα.
				  }
				  signLeft = i;//Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε
				  i = 5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας 
			  }
			  i++; // βήμα 1 για το i
		  }
		  
		  i = 1;//Αρχικοποίηση μεταβλητής i 
		  
		  while((i <= 4)&&(i <= GomokuUtilities.NUMBER_OF_COLUMNS - x - 1)){//Επανάληψη που χρησιμεύει ώστε να μην ξεφύγουμε από την ευθεία χ=14 ( δεξί όριο του πίνακα ) και να ελέγξουμε μέγιστα 4 κελιά δεξιά από τη θέση που εξετάζουμε 
			  if(Id==board.getTile(x+i,y).getColor()){ //Έλεγχος άμα το κελί που είναι δεξιά  από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
				 
				  numHorizontalRight++;  //Αύξηση του αριθμού συνεχόμενων κελιών με ίδιο χρώμα με το δικό μας ( Έλεγχος από δεξιά)
				  
			  }else if(board.getTile(x+i,y).getColor() == 0){//Έλεγχος άμα το κελί που είναι δεξιά από αυτό που ελέγχουμε έχει χρώμα γκρι.
				  
				  i = 5;  // Στην περίπτωση γκρι χρώματος βγαίνουμε από την επανάληψη
			  
			  }else{//Έλεγχος άμα το κελί που είναι δεξιά  από αυτό που ελέγχουμε έχει χρώμα αντίθετο από το δικό μας.
				 
				  if(numHorizontalRight != 0){ ////Έλεγχος άμα ο αριθμός συνεχόμενων κελιών του ίδιου χρώματος με το χρώμα του παίκτη μας είναι μεγαλύτερο-διάφορο του μηδενός.
					//Ο έλεγχος αυτός γίνεται για να δούμε αμα το ακριβώς δεξιά μας κελί είναι αντίθετου χρώματος.
					  horizontalRight=1; //flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα.
					  
				  }
				  
				  signRight = i;  //Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε
				  
				  i = 5;  //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας 
			  }
			  i++;  //βήμα 1 για το i
			  
		  }
		  //Συνολικός οριζόντιος αθροιστής. Μας δίνει το άθροισμα συνεχώμενων κελιών ίδιου χρώματος με το χρώμα του παίκτη μας από τα αριστερά + (και ) από τα δεξία (π.χ πεντάδα , τετράδα κτλπ συνεχώμενων ομόχρομων κελιών)
		  numHorizontal = numHorizontalRight + numHorizontalLeft;
		  //Ξεκινάει το  evaluation 
		 
		  if(numHorizontal >= 4){ // Περίπτωση ύπαρξης 4 ή περισσότερων συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			  valueHorizontal = 100; //Εκχώρηση μέγιστης τιμής στο  value στην περίπτωση αυτή
		  }else if(numHorizontal == 3){ // Περίπτωση ύπαρξης 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά αριστερά και δεξία έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueHorizontal = 90; // Εκχώρηση τιμής 90 στο valueHorizontal
			  if (horizontalLeft==1){ // Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα αριστερά με κελί αντίθετου χρώματος 
				  valueHorizontal=valueHorizontal/3; //Αν η τριάδα  είναι κλειστή από τα αριστερά διαιρούμε το value της με 3
				  }else if (horizontalRight==1){  // Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα δεξιά με κελί αντίθετου χρώματος 
					  valueHorizontal=valueHorizontal/3; // Αν η τριάδα είναι κλειστή από τα δεξιά διαιρούμε το value της με 3
				  }
		  }else if(numHorizontal == 2){ // Περίπτωση ύπαρξης 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			  valueHorizontal = 30;// Εκχώρηση τιμής 30 στο  valueHorizontal
			  if (horizontalLeft==1){ // Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα αριστερά με κελί αντίθετου χρώματος 
				  valueHorizontal=valueHorizontal/3;//Αν η δυάδα  είναι κλειστή από τα αριστερά διαιρούμε το value της με 3
				  }else if (horizontalRight==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα δεξιά με κελί αντίθετου χρώματος 
					  valueHorizontal=valueHorizontal/3;// Αν η δυάδα είναι κλειστή από τα δεξιά διαιρούμε το value της με 3
				  }
		  }else if(numHorizontal == 1){// Περίπτωση ύπαρξης 1  συνεχόμενου κελιού με χρώμα ίδιο με του παίκτη μας
			  valueHorizontal = 6;// Εκχώρηση τιμής 6 στο valueHorizontal
			  if (horizontalLeft==1){ // Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα αριστερά με κελί αντίθετου χρώματος 
				  valueHorizontal=valueHorizontal/3;//Αν το ένα κελί είναι κλειστό από τα αριστερά διαιρούμε το value του με 3
				  }else if (horizontalRight==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα δεξιά με κελί αντίθετου χρώματος 
					  valueHorizontal=valueHorizontal/3; // Αν το κελί  κλειστό από τα δεξιά διαιρούμε το value του με 3
				  }
		  }else{ //Περίπτωση μη δυνατότητας συνδυασμού κελιών
			  valueHorizontal = 0; // Εκχώρηση ελάχιστης τιμής στο valueHorizontal
		  }
		  if((signLeft+signRight <= 5)){//Αν η απόσταση του πλησιέστερου από τα αριστερά κελιού αντίθετου χρώματος και του πλησιέστερου από τα δεξιά αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  valueHorizontal = 0; //Εκχώρηση ελάχιστης τιμής στο valueHorizontal
		  }
		  if(signRight + x < 5){ //Αν η απόσταστη του ορίου του πίνακα από τα αριστερά και η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από τα δεξιά αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  valueHorizontal = 0;//Εκχώρηση ελάχιστης τιμής στο valueHorizontal
		  }
		  if(GomokuUtilities.NUMBER_OF_COLUMNS - 1 - x + signLeft < 5){//Αν η απόσταση του ορίου του πίνακα από τα δεξιά και του πλησιέστερου κελιού αντίθετου χρώματος από τα αριστερά είναι μικρότερη ή ίση του 5 (Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  valueHorizontal = 0;//Εκχώρηση ελάχιστης τιμής στο valueHorizontal
		  }
		  
		  
		  return valueHorizontal; // Επιστροφή της valueHorizontal
		  
	  }
	  /*Δήλωση και Υλοποίηση της συνάρτησης checkVerticalValue
	   * Υπολογίζει το value των συνδυασμών που γίνονται κάθετα π.χ κάθετη τετράδα,τριάδα κλπ. λαμβάνοντας υπόψη
	   *  τα όρια του πίνακα.
	   * 
	   * 
	   * 
	   * */
	  
	  int checkVerticalValue(int x,int y,Board board,int Id){
		  int i = 1;//Δήλωση μίας μεταβλητής που χρησιμεύει στις επαναλήψεις
		  int verticalTop=0,verticalDown=0;//Δήλωση μεταβλητής με την μορφή flag που υποδηλώνει την ύπαρξη κελιού αντίθετου χρώματος από του Id που του αποκλείει την δυνατότητα συνέχισης συνδυασμού από πάνω ή προς τα κάτω.
		  int numVerticalDown = 0,numVerticalTop=0,numVertical=0;//Αθροιστής συνεχόμενων κελιών του χρώματος του Id κάτω,πάνω καθώς και ολικά. 
		  int sizeDown = 0,sizeTop=0;//Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση των ορίων του ταμπλό από το κελί που εξετάζουμε.
		  int signTop=100,signDown=100;//Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση του πλησιέστερου κελιού με αντίθετο χρώμα από το κελί που εξετάζουμε.Αντίστοιχα μία από την πάνω και μία από την κάτω πλευρά.
		  int valueVertical = 0;//Δήλωση μεταβλητής που θα έχει το value των κάθετων συνδυασμών.
		  
		  
		  while((i <= 4)&&( i <= y)){//Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε κάτω από την ευθεία y=0 και να ελέγξουμε μέγιστα 4 κελιά κάτω από την θέση που εξετάζουμε.
			//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
			  sizeDown++;//Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeDown πόση επιτρεπτή απόσταση έχουμε από κάτω.
			  i++;//βήμα 1 για το i
		  }
		  
		  i=1;//Αρχικοποίηση της μεταβλητής i
		  
		  while(i<=sizeDown){//Επανάληψη που γίνεται μέγιστο sizeDown φορές.
			  if(Id==board.getTile(x,y-i).getColor()){//Έλεγχος άμα το κελί που είναι κάτω από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
				  numVerticalDown++;//Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας από κάτω.
			  }else if(board.getTile(x, y-i).getColor()==0){//Έλεγχος άμα το κελί που είναι κάτω από αυτό που ελέγχουμε έχει γκρι χρώμα.
				  i	=5;//Σε περίπτωση γκρι χρώματος αυξάνουμε τον μετρητή σε μη επιτρεπτή τιμή ώστε να βγει από την επανάληψη,αφού σπάει το σερί του χρώματος μας.
				  
			  }
			  else{//Έλεγχος άμα το κελί που είναι κάτω από αυτό που ελέγχουμε έχει αντίθετο χρώμα από το δικό μας.
				  verticalDown=1;//flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα κάτω από αυτό που ελέγχουμε.
				  signDown = i;//Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
				  i = 5;//i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας 
			  }
			  i++;//βήμα 1 για το i
		  }
		 
		  i = 1;//Αρχικοποίηση της μεταβλητής i
		  
		  while((i <= 4)&&(i <= GomokuUtilities.NUMBER_OF_ROWS - y - 1)){//Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε πάνω από την ευθεία y=14 και να ελέγξουμε μέγιστα 4 κελιά πάνω από την θέση που εξετάζουμε.
			//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
			  sizeTop++;//Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeTop πόση επιτρεπτή απόσταση έχουμε από πάνω.
			  i++;//βήμα 1 για το i
		  }
		  
		  i=1; //Αρχικοποίηση της μεταβλητής i
		  
		  while(i<=sizeTop){//Επανάληψη που γίνεται μέγιστο sizeTop φορές.
			  if(Id==board.getTile(x,y+i).getColor()){//Έλεγχος άμα το κελί που είναι πάνω από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
				  numVerticalTop++;//Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας από πάνω.
			  }else if(board.getTile(x, y+i).getColor()==0){//Έλεγχος άμα το κελί που είναι πάνω από αυτό που ελέγχουμε έχει γκρι χρώμα.
				  i=5;//Σε περίπτωση γκρι χρώματος αυξάνουμε τον μετρητή σε μη επιτρεπτή τιμή ώστε να βγει από την επανάληψη,αφού σπάει το σερί του χρώματος μας.
			  }
			  else{//Έλεγχος άμα το κελί που είναι πάνω από αυτό που ελέγχουμε έχει αντίθετο χρώμα από το δικό μας.
				  verticalTop=1;//flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα πάνω από αυτό που ελέγχουμε.
				  signTop=i;//Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
				  i = 5;//i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας 
			  }
			  i++;//βήμα 1 για το i
		  }
		  
	//Συνολικός κάθετος αθροιστής. Μας δίνει το άθροισμα συνεχώμενων κελιών ίδιου χρώματος με το χρώμα του παίκτη μας από πάνω + (και ) από κάτω (π.χ πεντάδα , τετράδα κτλπ συνεχώμενων ομόχρομων κελιών)
		numVertical=numVerticalTop+numVerticalDown;  
		 //Ξεκινάει το  evaluation 
		
		  if(numVertical >= 4){// Περίπτωση ύπαρξης 4 ή περισσότερων συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			  valueVertical = 100; //Εκχώρηση μέγιστης τιμής στο  value στην περίπτωση αυτή
		  }else if(numVertical == 3){ // Περίπτωση ύπαρξης 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά πάνω και κάτω έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueVertical = 90;// Εκχώρηση τιμής 90 στο valueVertical
			  if (verticalTop==1){// Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω με κελί αντίθετου χρώματος 
				  valueVertical=valueVertical/3;//Αν η τριάδα  είναι κλειστή από πάνω διαιρούμε το value της με 3
				  }else if (verticalDown==1){// Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω με κελί αντίθετου χρώματος 
					  valueVertical=valueVertical/3;//Αν η τριάδα  είναι κλειστή από πάνω διαιρούμε το value της με 3
				  }
		  }else if(numVertical == 2){// Περίπτωση ύπαρξης 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			  valueVertical = 30;// Εκχώρηση τιμής 30 στο valueVertical
			  if (verticalTop==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω με κελί αντίθετου χρώματος 
				  valueVertical=valueVertical/3;//Αν η δυάδα  είναι κλειστή από πάνω διαιρούμε το value της με 3
				  }else if (verticalDown==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω με κελί αντίθετου χρώματος 
					  valueVertical=valueVertical/3;//Αν η δυάδα  είναι κλειστή από κάτω διαιρούμε το value της με 3
				  }
		  }else if(numVertical == 1){// Περίπτωση ύπαρξης 1  συνεχόμενου κελιού με χρώμα ίδιο με του παίκτη μας
			  valueVertical = 6;// Εκχώρηση τιμής 6 στο valueVertical
			  if (verticalTop==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω με κελί αντίθετου χρώματος 
				  valueVertical=valueVertical/3;//Αν το ένα κελί είναι κλειστό από τα πάνω διαιρούμε το value του με 3
				  }else if (verticalDown==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω με κελί αντίθετου χρώματος 
					  valueVertical=valueVertical/3;//Αν το ένα κελί είναι κλειστό από κάτω διαιρούμε το value του με 3
				  }
		  }else{//Περίπτωση μη δυνατότητας συνδυασμού κελιών
			  valueVertical = 0;// Εκχώρηση ελάχιστης τιμής στο valueHorizontal
		  }
		  
		  if((signDown+signTop<=5)){//Αν η απόσταση του πλησιέστερου από πάνω κελιού αντίθετου χρώματος και του πλησιέστερου από κάτω αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  
			  valueVertical=0;// Εκχώρηση ελάχιστης τιμής στο valueHorizontal
			  
		  }
		  if(signTop + y < 5){//Αν η απόσταστη του ορίου του πίνακα από κάτω και η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από πάνω αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  
			  valueVertical = 0;// Εκχώρηση ελάχιστης τιμής στο valueHorizontal
			  
		  }
		  if(GomokuUtilities.NUMBER_OF_ROWS - 1 - y + signDown < 5){//Αν η απόσταση του ορίου του πίνακα από πάνω και του πλησιέστερου κελιού αντίθετου χρώματος από κάτω είναι μικρότερη ή ίση του 5 (Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  
			 valueVertical = 0; // Εκχώρηση ελάχιστης τιμής στο valueHorizontal
			 
		  }
		  
		  return valueVertical;// Επιστροφή της valueVertical
	  }
	  
	  
	  /*Δήλωση και Υλοποίηση της συνάρτησης checkDiagonaValue1
	   * Υπολογίζει το value των συνδυασμών που γίνονται στην πρώτη διαγώνιο (y=-x+c) π.χ κάθετη τετράδα,τριάδα κλπ. λαμβάνοντας υπόψη
	   *  τα όρια του πίνακα.
	   * 
	   * 
	   * 
	   * */
	  
	  int checkDiagonalValue1(int x,int y,Board board,int Id){
		  int diagonal1Down = 0,diagonal1Top = 0; //Δήλωση μεταβλητής με την μορφή flag που υποδηλώνει την ύπαρξη κελιού αντίθετου χρώματος από του Id που του αποκλείει την δυνατότητα συνέχισης συνδυασμού από πάνω αριστερά  ή προς τα κάτω δεξιά.
		  int numDiagonal1 = 0,numDiagonal1Top = 0,numDiagonal1Down = 0;//Αθροιστής συνεχόμενων κελιών του χρώματος του Id κάτω δεξιά ,πάνω αριστερά καθώς και ολικά. 
		  int signDiagonal1Down=100,signDiagonal1Top=100; //Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση του πλησιέστερου κελιού με αντίθετο χρώμα από το κελί που εξετάζουμε.Αντίστοιχα μία από την πάνω αριστερά και μία από την κάτω δεξιά πλευρά.
		  int valueDiagonal1 = 0; //Δήλωση μεταβλητής που θα έχει το value των διαγώνιων (y=-x+c) συνδυασμών.
		  int sizeDiagonal1Down = 0,sizeDiagonal1Top = 0;//Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση των ορίων του ταμπλό από το κελί που εξετάζουμε.
		  int i = 1; //Δήλωση μιας μεταβλητής που χρησιμεύει στις επαναλήψεις
		  
		  int sumColRow = GomokuUtilities.NUMBER_OF_COLUMNS-1 + GomokuUtilities.NUMBER_OF_ROWS - 1; //Άθροισμα διαστάσεων πίνακα -2 (28)
		  
		  while((i<=4)&&(y-i>=0)&&(x+i<=GomokuUtilities.NUMBER_OF_COLUMNS-1)){//Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε κάτω από την ευθεία y=0 ,δεξιά από την x=14 και να ελέγξουμε μέγιστα 4 κελιά κάτω δεξιά από την θέση που εξετάζουμε.
				//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
			  sizeDiagonal1Down++;//Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeDiagonal1Down πόση επιτρεπτή απόσταση έχουμε από κάτω δεξιά.
			  i++; //Βήμα 1 για το i
		  }
		  
		  i=1; //Αρχικοποίηση της μεταβλητής i
		  
		  if((y+x>=4)&&(y+x < sumColRow - 3)){//Διαγώνιες που σχηματίζουν πεντάδα σε είδη ευθειών y = -x + c (αποκλείει ουσιαστικά αυτές που δεν σχηματίζουν)
			  while(i<=sizeDiagonal1Down){//Επανάληψη που γίνεται μέγιστο sizeDiagona1Down φορές.
				  if(Id==board.getTile(x+i,y-i).getColor()){//Έλεγχος άμα το κελί που είναι κάτω δεξιά από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					  numDiagonal1Down++;  //Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας προς τα κάτω δεξιά
				  }else if (board.getTile(x+i, y-i).getColor()==0){//Έλεγχος άμα το κελί που είναι κάτω δεξιά από αυτό που ελέγχουμε έχει γκρι χρώμα.
					  i=5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση γκρι χρώματος.
				  }
				  else{//Έλεγχος άμα το κελί που είναι πάνω από αυτό που ελέγχουμε έχει χρώμα αντίθετο από το δικό μας.
					  diagonal1Down=1;  //flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα κάτω δεξιά από αυτό που ελέγχουμε.
					  signDiagonal1Down=i;  //Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
					  i=5;  //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας
				  } 
				  i++;	   //Βήμα 1 για το i
			  }
			  
			i = 1;  //Αρχικοποίηση της μεταβλητής i
		  
			while ((i<=4)&&(x-i>=0)&&(y+i<=GomokuUtilities.NUMBER_OF_COLUMNS-1)){//Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε πάνω από την ευθεία y=14 ,αριστερά από την x=0 και να ελέγξουμε μέγιστα 4 κελιά πάνω αριστερά από την θέση που εξετάζουμε.
				//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
				sizeDiagonal1Top++; //Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeDiagonal1Top πόση επιτρεπτή απόσταση έχουμε από πάνω αριστερά.
				i++;  //Βήμα 1 για το i
			}
			i=1;  //Αρχικοποίηση της μεταβλητής i
			while (i<=sizeDiagonal1Top){//Επανάληψη που γίνεται μέγιστο sizeDiagonal1Top φορές.
				if(Id==board.getTile(x-i,y+i).getColor()){//Έλεγχος άμα το κελί που είναι πάνω αριστερά  από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					numDiagonal1Top++;//Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας προς τα πάνω αριστερά 
				}else if(board.getTile(x-i, y+i).getColor()==0){//Έλεγχος άμα το κελί που είναι πάνω αριστερά  από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					i=5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση γκρι χρώματος
				}
				else {//Έλεγχος άμα το κελί που είναι πάνω από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					diagonal1Top=1;  //flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα πάνω αριστερά από αυτό που ελέγχουμε.
					signDiagonal1Top=i;  //Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
					i=5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας
				}
				
				i++;  //Βήμα 1 για το i
			}
		 }
		  //Εκχώρηση αθροίσματος συνεχόμενων κελιών προς τα πάνω αριστερά και προς τα κάτω δεξιά σε μία ολική μεταβλητή
		  numDiagonal1=numDiagonal1Top+numDiagonal1Down;
		  
		  if (numDiagonal1>=4){// Περίπτωση ύπαρξης 4 ή περισσότερων συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			  valueDiagonal1=100; //Εκχώρηση μέγιστης τιμής στο  value στην περίπτωση αυτή
		  }else if(numDiagonal1==3){// Περίπτωση ύπαρξης 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά διαγωνίως (y=-x+c) έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueDiagonal1=90;// Εκχώρηση τιμής 90 στο valueDiagonal1
			  if (diagonal1Top==1){  // Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω αριστερά  με κελί αντίθετου χρώματος 
				  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από πάνω αριστερά διαιρούμε το value του με 3
				  }else if (diagonal1Down==1){// Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω δεξιά με κελί αντίθετου χρώματος 
					  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από κάτω δεξιά διαιρούμε το value του με 3
				  }
		  }else if(numDiagonal1==2){// Περίπτωση ύπαρξης 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά διαγωνίως (y=-x+c) έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueDiagonal1=30; // Εκχώρηση τιμής 30 στο valueDiagonal1
			  if (diagonal1Top==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω αριστερά με κελί αντίθετου χρώματος 
				  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από τα πάνω αριστερά  διαιρούμε το value του με 3
				  }else if (diagonal1Down==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω δεξιά με κελί αντίθετου χρώματος 
					  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από τα κάτω αριστερά διαιρούμε το value του με 3
				  }
		  }else if(numDiagonal1==1){// Περίπτωση ύπαρξης 1 κελιού με χρώμα ίδιο με του παίκτη μας το οποίο διαγωνίως (y=-x+c) έχει γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueDiagonal1=6;// Εκχώρηση τιμής 6 στο valueDiagonal1
			  if (diagonal1Top==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω αριστερά με κελί αντίθετου χρώματος 
				  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από τα πάνω αριστερά διαιρούμε το value του με 3
				  }else if (diagonal1Down==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω δεξιά με κελί αντίθετου χρώματος 
					  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από τα κάτω δεξιά διαιρούμε το value του με 3
				  }
		  }else{ //Περίπτωση μη δυνατότητας συνδυασμού κελιών
			  valueDiagonal1 =0; // Εκχώρηση ελάχιστης τιμής στο valueDiagonal1
		  }
		    if ((signDiagonal1Down+signDiagonal1Top<=5)){//Αν η απόσταση του πλησιέστερου από πάνω αριστερά κελιού αντίθετου χρώματος και του πλησιέστερου από κάτω δεξιά αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)  
		    	valueDiagonal1=0;// Εκχώρηση ελάχιστης τιμής στο valueDiagonal1
		    }
		    if(( x + signDiagonal1Down < 5 )||(GomokuUtilities.NUMBER_OF_ROWS - 1 - y + signDiagonal1Down < 5)){//Αν οι αποστάσεις του ορίου του πίνακα από πάνω διαγωνίως και η απόσταση του ορίου του πίνακα από αριστερά διαγωνίως είναι μικρότερες του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
		    	valueDiagonal1 = 0 ;// Εκχώρηση ελάχιστης τιμής στο valueDiagonal1
		    }
		    if((y + signDiagonal1Top < 5)||(GomokuUtilities.NUMBER_OF_ROWS - 1 - x + signDiagonal1Top < 5)){//Αν οι αποστάσεις  του ορίου του πίνακα από κάτω διαγωνίως και η απόσταση του ορίου του πίνακα από δεξιά διαγωνίως είναι μικρότερες του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
		    	valueDiagonal1 = 0 ;// Εκχώρηση ελάχιστης τιμής στο valueDiagonal1
		    }
		    return valueDiagonal1;  //Επιστροφή της ValueDiagonal1
	  }
	  
	  /*Δήλωση και Υλοποίηση της συνάρτησης checkDiagonaValue2
	   * Υπολογίζει το value των συνδυασμών που γίνονται στην δεύτερη διαγώνιο (y=x+c) π.χ κάθετη τετράδα,τριάδα κλπ. λαμβάνοντας υπόψη
	   *  τα όρια του πίνακα.
	   * 
	   * 
	   * 
	   * */
	 int checkDiagonalValue2(int x,int y,Board board,int Id){
		 
		 int diagonal2Down = 0, diagonal2Top = 0; //Δήλωση μεταβλητής με την μορφή flag που υποδηλώνει την ύπαρξη κελιού αντίθετου χρώματος από του Id που του αποκλείει την δυνατότητα συνέχισης συνδυασμού από πάνω δεξιά ή προς τα κάτω αριστερά.
		 int signDiagonal2Top = 100, signDiagonal2Down = 100; //Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση του πλησιέστερου κελιού με αντίθετο χρώμα από το κελί που εξετάζουμε.Αντίστοιχα μία από την πάνω δεξιά και μία από την κάτω αριστερά πλευρά.
		 int valueDiagonal2 = 0; //Δήλωση μεταβλητής που θα έχει το value των διαγώνιων (y=x+c) συνδυασμών.
		 int sizeDiagonal2Down = 0, sizeDiagonal2Top = 0; //Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση των ορίων του ταμπλό από το κελί που εξετάζουμε.
		 int  i = 1; //Δήλωση μιας μεταβλητής που χρησιμεύει στις επαναλήψεις
		 int numDiagonal2 = 0, numDiagonal2Top = 0, numDiagonal2Down = 0; //Αθροιστής συνεχόμενων κελιών του χρώματος του Id κάτω αριστερά ,πάνω δεξιά καθώς και ολικά. 
		 
		 while((i<=4)&&(y-i>=0)&&(x-i>=0)){ //Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε κάτω από την ευθεία y=0 ,αριστερά από την x=0 και να ελέγξουμε μέγιστα 4 κελιά κάτω αριστερά από την θέση που εξετάζουμε.
			//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
			 sizeDiagonal2Down++; //Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeDiagonal2Down πόση επιτρεπτή απόσταση έχουμε από κάτω αριστερά.
			 i++; //Βήμα 1 για το i
		 }
		 
		 i=1;//Αρχικοποίηση της μεταβλητής i
		 
		 if ((x-y<GomokuUtilities.NUMBER_OF_COLUMNS-4)&&(y-x<GomokuUtilities.NUMBER_OF_COLUMNS-4)){ //Διαγώνιες που σχηματίζουν πεντάδα σε είδη ευθειών y = x + c (Αποκλείει αυτές που δεν σχηματίζουν)
			 while (i <= sizeDiagonal2Down){//Επανάληψη που γίνεται μέγιστο sizeDiagona2Down φορές.
				 if(Id==board.getTile(x-i,y-i).getColor()){//Έλεγχος άμα το κελί που είναι κάτω αριστερά από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					 numDiagonal2Down++; //Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας προς τα κάτω αριστερά.
				 }else if(board.getTile(x-i,y-i).getColor() ==0 ){//Έλεγχος άμα το κελί που είναι κάτω αριστερά  από αυτό που ελέγχουμε έχει χρώμα αντίθετο με το δικό μας.
					 i = 5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση γκρι χρώματος
				 }else{//Έλεγχος άμα το κελί που είναι κάτω αριστερά  από αυτό που ελέγχουμε έχει γκρι χρώμα.
					 diagonal2Down=1;  //flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα κάτω αριστερά από αυτό που ελέγχουμε.
					 signDiagonal2Down = i;//Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
					 	i = 5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας
					  }
				 i++;//Βήμα 1 για το i
			 } 
			 
			 i = 1;//Αρχικοποίηση της μεταβλητής i
			 
			 while((i<=4)&&(x+i<=GomokuUtilities.NUMBER_OF_COLUMNS-1)&&(y+i<=GomokuUtilities.NUMBER_OF_COLUMNS-1)){ //Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε πάνω από την ευθεία y=14 ,δεξιά από την x=14 και να ελέγξουμε μέγιστα 4 κελιά πάνω δεξιά από την θέση που εξετάζουμε.
				//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
				 sizeDiagonal2Top++; //Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeDiagonal2Top πόση επιτρεπτή απόσταση έχουμε από πάνω δεξιά.
				 i++;//Βήμα 1 για το i
			 }
			 

			i = 1;//Αρχικοποίηση της μεταβλητής i
			
			 while (i <= sizeDiagonal2Top){ //Επανάληψη που γίνεται μέγιστο sizeDiagonal2Top φορές.
				 if(Id==board.getTile(x+i,y+i).getColor()){//Έλεγχος άμα το κελί που είναι πάνω δεξιά  από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					 numDiagonal2Top++; //Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας προς τα πάνω δεξιά.
				 }else if(board.getTile(x+i,y+i).getColor()==0){//Έλεγχος άμα το κελί που είναι πάνω δεξιά  από αυτό που ελέγχουμε έχει χρώμα αντίθετο με το δικό μας.
					 i = 5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση γκρι χρώματος
				 }else{ //Έλεγχος άμα το κελί που είναι πάνω δεξιά από αυτό που ελέγχουμε έχει γκρι χρώμα.
					 diagonal2Top=1;  //flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα πάνω δεξιά από αυτό που ελέγχουμε.
					 signDiagonal2Top = i; //Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
					 i=5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας
				 }
				 i++;//Βήμα 1 για το i
				}
			}
		  //Εκχώρηση αθροίσματος συνεχόμενων κελιών προς τα πάνω δεξιά και προς τα κάτω αριστερά σε μία ολική μεταβλητή
		 numDiagonal2=numDiagonal2Down+numDiagonal2Top;
		 
		 if (numDiagonal2>=4){// Περίπτωση ύπαρξης 4 ή περισσότερων συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			 valueDiagonal2=100; //Εκχώρηση μέγιστης τιμής στο  value στην περίπτωση αυτή
		 }else if(numDiagonal2==3){//Περίπτωση ύπαρξης 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά διαγωνίως (y=x+c) έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			 valueDiagonal2=90;// Εκχώρηση τιμής 90 στο valueDiagonal2
			 if (diagonal2Top==1){// Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω δεξιά  με κελί αντίθετου χρώματος 
				 valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από πάνω δεξιά διαιρούμε το value του με 3
			 }else if (diagonal2Down==1){// Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω αριστερά  με κελί αντίθετου χρώματος 
				 valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από κάτω αριστερά διαιρούμε το value του με 3
			 }
		  }else if(numDiagonal2==2){//Περίπτωση ύπαρξης 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά διαγωνίως (y=x+c) έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueDiagonal2=30;// Εκχώρηση τιμής 30 στο valueDiagonal2
			  if (diagonal2Top==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω δεξιά με κελί αντίθετου χρώματος 
				  valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από τα πάνω δεξιά διαιρούμε το value του με 3
			  }else if (diagonal2Down==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω αριστερά  με κελί αντίθετου χρώματος 
				  valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από τα κάτω αριστερά διαιρούμε το value του με 3
			  }
		  }else if(numDiagonal2==1){// Περίπτωση ύπαρξης 1 κελιού με χρώμα ίδιο με του παίκτη μας το οποίο διαγωνίως (y=x+c) έχει γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueDiagonal2=6;// Εκχώρηση τιμής 6 στο valueDiagonal2
			  if (diagonal2Top==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω δεξιά με κελί αντίθετου χρώματος 
				  valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από τα πάνω δεξιά διαιρούμε το value του με 3  
			  }else if (diagonal2Down==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω αριστερά με κελί αντίθετου χρώματος 
					  valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από τα κάτω αριστερά διαιρούμε το value του με 3
			  }
		  }else{ //Περίπτωση μη δυνατότητας συνδυασμού κελιών
			  valueDiagonal2=0; // Εκχώρηση ελάχιστης τιμής στο valueDiagonal2
		  }
		 if(((signDiagonal2Down+signDiagonal2Top) <=5)){//Αν η απόσταση του πλησιέστερου από πάνω δεξιά κελιού αντίθετου χρώματος και του πλησιέστερου από κάτω αριστερά αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			 valueDiagonal2 = 0; // Εκχώρηση ελάχιστης τιμής στο valueDiagonal2
		 }
		 if(( GomokuUtilities.NUMBER_OF_ROWS -1 - x + signDiagonal2Down < 5 )||(GomokuUtilities.NUMBER_OF_ROWS - 1 - y + signDiagonal2Down < 5)){//Αν οι αποστάσεις του ορίου του πίνακα από πάνω διαγωνίως και η απόσταση του ορίου του πίνακα από δεξιά διαγωνίως είναι μικρότερες του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			 valueDiagonal2 = 0 ; // Εκχώρηση ελάχιστης τιμής στο valueDiagonal2
		 }
		 if((y + signDiagonal2Top < 5)||( x + signDiagonal2Top < 5)){//Αν οι αποστάσεις του ορίου του πίνακα από κάτω διαγωνίως και η απόσταση του ορίου του πίνακα από αριστερά διαγωνίως είναι μικρότερες του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			 valueDiagonal2 = 0 ; // Εκχώρηση ελάχιστης τιμής στο valueDiagonal2
		 }
		  return valueDiagonal2; //Επιστροφή της ValueDiagonal2
	  }
	  
	 
	
}
