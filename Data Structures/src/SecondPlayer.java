import java.util.ArrayList;
public class SecondPlayer implements AbstractPlayer{
	 int score;//Δήλωση της μεταβλητής σκορ
	  int id;//Δήλωση της μεταβλητής id που υποδηλώνει το χρώμα του παίκτη
	  String name;//Δήλωση της μεταβλητής name
	  int [][]weight = new int [GomokuUtilities.NUMBER_OF_COLUMNS][GomokuUtilities.NUMBER_OF_ROWS];//Δήλωση του δισδιάστατου πίνακα weight τον οποίο χρησιμοποιήσαμε για να δώσουμε value κεντρικότητας σε κάθε τετράγωνο

	  //Δήλωση και υλοποίηση του "κενού" constructor της κλάσης HeuristicPlayer
	  public SecondPlayer (Integer pid)
	  {
		  //Ανάθεση τιμών στις μεταβλητές id,score 
	    id = pid; 
	    score = 0;
	    setWeight();  //Κλήση της συνάρτησης weight
	  }
	 //Δήλωση και υλοποίηση του constructor  της κλάσης  HeuristicPlayer
	  public SecondPlayer(Integer pid, int pscore, String pname){
		  //Ανάθεση τιμών στις μεταβλητές id,score 
		  score = pscore;
		  id = pid;
		  name=pname;
		  setWeight();   //Κλήση της συνάρτησης weight
	  }
	//Δήλωση και υλοποίηση συνάρτησης getName
	  public String getName ()
	  {

	    return "Heuristic";  //Επιστροφή της τιμής 

	  }
	//Δήλωση και υλοποίηση συνάρτησης getId
	  public int getId ()
	  {	
		  
	    return id;   //Επιστροφή της τιμής 
	    
	  }

	//Δήλωση και υλοποίηση συνάρτησης setScore
	  public void setScore (int score)
	  {
		  
	    this.score = score;   //Ανάθεση τιμής στην μεταβλητή score
	    
	  }
	//Δήλωση και υλοποίηση συνάρτησης getScore
	  public int getScore ()
	  {
		  
	    return score;    //Επιστροφή της τιμής
	    
	  }
	//Δήλωση και υλοποίηση συνάρτησης setId
	  public void setId (int id)
	  {
	   
	    this.id = id;   //Ανάθεση τιμής στη μεταβλητή  id

	  }
	//Δήλωση και υλοποίηση συνάρτησης setName
	  public void setName (String name)
	  {
	    
	    this.name = name;   //Ανάθεση τιμής στη μεταβλητή name

	  }
	//Δήλωση και υλοποίηση συνάρτησης getWeight
	  public int getWeight(int x,int y){
		  
		  return weight[x][y];  //Επιστροφή τιμής του πίνακα που στο αντιστοιχεί στο value κεντρικότητας της θέσης x,y
		  
	  }
	//Δήλωση και υλοποίηση συνάρτησης setWeight
	  void setWeight(){
		  weight[(GomokuUtilities.NUMBER_OF_COLUMNS-1)/2][(GomokuUtilities.NUMBER_OF_ROWS-1)/2] = 7; //Ανάθεση της τιμής 7 (μέγιστη τιμή του πίνακα) στο κεντρικότερο κελί του πίνακα 
		  //Διπλή επανάληψη για εκχώρηση τιμών στα τρίγωνα που ενώνουν την πάνω αριστερή γωνία και την κάτω αριστερή γωνία με το κέντρο καθώς και την πάνω δεξία και την κάτω δεξιά γωνία και το κέντρο του board.
		  for(int i = 0 ; i <= 6 ; i++ ){
			  for(int j = i ; j <= GomokuUtilities.NUMBER_OF_ROWS - i - 1 ; j++){
				  weight[i][j] = i;  // Ανάθεση τιμών στα κελιά του πίνακα μέσω διπλής επανάληψης ανάλογα με την κεντρικότητα τους 
				  weight[GomokuUtilities.NUMBER_OF_COLUMNS-1-i][j] = i;   // Ανάθεση τιμών στα κελιά του πίνακα μέσω διπλής επανάληψης ανάλογα με την κεντρικότητα τους 
			  }
		  }
		  //Διπλή επανάληψη για εκχώρηση τιμών στα τρίγωνα που ενώνουν την πάνω αριστερή γωνία και την πάνω δεξιά γωνία με το κέντρο καθώς και την κάτω δεξιά και την κάτω αριστερή γωνία και το κέντρο του board.
		  for(int j = 0 ; j <= 6 ; j++ ){
			  for(int i = j ; i <= GomokuUtilities.NUMBER_OF_COLUMNS - j - 1 ; i++){
				  weight[i][j] = j;  // Ανάθεση τιμών στα κελιά του πίνακα μέσω διπλής επανάληψης ανάλογα με την κεντρικότητα τους 
				  weight[i][GomokuUtilities.NUMBER_OF_ROWS-1-j] = j;  // Ανάθεση τιμών στα κελιά του πίνακα μέσω διπλής επανάληψης ανάλογα με την κεντρικότητα τους 
			  }
		  }
		  
	  }
	//Δήλωση και υλοποίηση συνάρτησης getNextMove που επιστρέφει την επόμενη θέση του παίκτη.
	  public int[] getNextMove (Board board)
	  {
	     // TODO
		  int myId,enemyId;//Δήλωση μεταβλητών myId και enemyId
		  myId=this.getId();//Εκχώρηση του id του πρώτου παίκτη
		  if (myId==1){//Έλεγχος για να βρούμε το id του αντιπάλου.
			  enemyId=2;
		  }else {
			  enemyId=1;
		  }
		  int [] position = new int [2];//Δήλωση πίνακα στον οποίο αποθηκεύεται η κίνηση μας 
		  int [] positionEnemy = new int [2];//Δήλωση πίνακα στον οποίο αποθηκεύεται η κίνηση του αντιπάλου
		  ArrayList<int[]> thisArrayList = new ArrayList<int []>();//Δήλωση ArrayList για την αποθήκευση πινάκων που περιέχουν τις συντεταγμένες κάθε κελιού με το value του με βάση την κίνηση του πρώτου παίκτη.
		  ArrayList<int[]> thisArrayListEnemy = new ArrayList<int []>();//Δήλωση ArrayList για την αποθήκευση πινάκων που περιέχουν τις συντεταγμένες κάθε κελιού με το value του με βάση την κίνηση του αντιπάλου.
		  //Διπλή επανάληψη για την σάρωση του board
		  for(int i=0;i<GomokuUtilities.NUMBER_OF_ROWS;i++){
			  for(int j=0;j<GomokuUtilities.NUMBER_OF_COLUMNS;j++){
				  if(board.getTile(i, j).getColor() == 0){//Έλεγχος για την ύπαρξη γκρι κελιού(κενού)
					int [] myArray = new int [3];//Δήλωση πίνακα που αποθηκεύουμε τις συντεταγμένες του ενός κελιού και το value του με βάση την κίνηση του πρώτου παίκτη.
					int [] arrayEnemy = new int [3];//Δήλωση πίνακα που αποθηκεύουμε τις συντεταγμένες του ενός κελιού και το value του με βάση την κίνηση του αντιπάλου.
					myArray[0] = i;//Εκχώρηση της τετμημένης 
				  	myArray[1] = j;//Εκχώρηση της τεταγμένης
				  	myArray[2] = evaluate(i,j,board,myId);//Κλήση της evaluate ώστε να πάρουμε το value του κελιού που ελέγχουμε και καταχώρηση αυτής της τιμής στον πίνακα.
				  	thisArrayList.add(myArray);//Εκχώρηση του πίνακα myArray στην thisArrayList
				  	arrayEnemy[0] = i;//Εκχώρηση της τετμημένης 
				  	arrayEnemy[1] = j;//Εκχώρηση της τεταγμένης
				  	arrayEnemy[2] = evaluate(i,j,board,enemyId);//Κλήση της evaluate ώστε να πάρουμε το value του κελιού που ελέγχουμε και καταχώρηση αυτής της τιμής στον πίνακα.
				  	thisArrayListEnemy.add(arrayEnemy);//Εκχώρηση του πίνακα arrayEnemy στην thisArrayListEnemy
				  }
			  }
		  }
		  int myMax = -1 ;//Δήλωση της μεταβλητής myMax ώστε να βρούμε το κελί με το μέγιστο value για την κίνηση του πρώτου παίκτη
		  int maxEnemy = -1;  //Δήλωση της μεταβλητής maxEnemy ώστε να βρούμε το κελί με το μέγιστο value για την κίνηση του αντιπάλου
		  for(int i = 0;i<thisArrayList.size();i++){
			 if(myMax < thisArrayList.get(i)[2]){ // Σύγκριση της τιμής πού έχουμε εκχωρήσει ως max με το value του επόμενου κενού κελιού για την κίνηση του πρώτου παίκτη
				 myMax = thisArrayList.get(i)[2];  //Θεωρώ ότι η το μέγιστο value όλων των κελιών είναι μοναδικό
				 position[0] = thisArrayList.get(i)[0];  //Εκχώρηση της τετμημένης του κελιού με max value
				 position[1] = thisArrayList.get(i)[1];  //Εκχώρηση της τεταγμένης του κελιού με max value
			 }
			 if(maxEnemy < thisArrayListEnemy.get(i)[2]){   // Σύγκριση της τιμής πού έχουμε εκχωρήσει ως max με το value του επόμενου κενού κελιού για την κίνηση του αντιπάλου
				 maxEnemy = thisArrayListEnemy.get(i)[2];  //Θεωρώ ότι η το μέγιστο value όλων των κελιών είναι μοναδικό
				 positionEnemy[0] = thisArrayList.get(i)[0];  //Εκχώρηση της τετμημένης του κελιού με max value
				 positionEnemy[1] = thisArrayList.get(i)[1]; //Εκχώρηση της τεταγμένης του κελιού με max value
			 }
		  }
		  if((maxEnemy > myMax)&&(maxEnemy >= 36)){ //Έλεγχος για το αν η κίνηση του αντιπάλου έχει μεγαλύτερο value από την δική μας και έλεγχος για το αν μας απειλεί αρκετά η κίνηση του
			  position[0] = positionEnemy[0];  //Ανάθεση της τετμημένης της κίνησης του αντιπάλου στα κελιά του πίνακα κίνησης του πρώτου παίκτη
			  position[1] = positionEnemy[1]; // Ανάθεση της τεταγμένης της κίνησης του αντιπάλου στα κελιά του πίνακα κίνησης του πρώτου παίκτη
		  }
		  return position; //Επιστροφή της θέσης που αποθηκεύτηκε 
	  }
	  /*Ορισμός και υλοποίηση συνάρτησης evaluate , η οποία επιστρέφει το  value του κάθε κελιού 
	   *Δέχεται ως όρισμα και το Id επειδή καλείται και από τον πρώτο παίκτη και από τον αντίπαλο του
	   * 
	   * */
	  int evaluate (int x, int y, Board board,int Id){
	  	  // TODO
		
		  
		  int valueCombo,valueCentrality,valueHorizontal,valueVertical,valueDiagonal1,valueDiagonal2;//Δήλωση μεταβλητών στις οποίες θα αποθηκευτούν τα οριζόντια,τα κάθετα και τα 2 είδη διαγωνίων value.Καθώς και το centrality και το συνολικό value.
		  valueHorizontal = checkHorizontalValue(x,y,board,Id);//Κλήση της συνάρτησης checkHorizontalValue και εκχώρηση της τιμής της.
		  valueVertical = checkVerticalValue(x,y,board,Id);//Κλήση της συνάρτησης checkVerticalValue και εκχώρηση της τιμής της.
		  valueDiagonal1 = checkDiagonalValue1(x,y,board,Id);//Κλήση της συνάρτησης checkDiagonalValue1 και εκχώρηση της τιμής της.
		  valueDiagonal2 = checkDiagonalValue2(x,y,board,Id);//Κλήση της συνάρτησης checkDiagonalValue2 και εκχώρηση της τιμής της.
		  valueCentrality = getWeight(x,y);//Κλήση της συνάρτησης getWeight και εκχώρηση της τιμής της.
		  
		  
		  //Έλεγχος για εύρεση πεντάδας προς όλες τις κατευθύνσεις ώστε να επιστραφεί απευθείας η μέγιστη επιτρεπτή τιμή.
		  if((valueHorizontal == 100)||(valueVertical == 100)||(valueDiagonal1 == 100)||(valueDiagonal2 == 100)){
			  return 400;//Επιστροφή μέγιστης τιμής(0-400 κλίμακα)
		  }
		  
		  valueCombo = valueHorizontal + valueVertical + valueDiagonal1 + valueDiagonal2;//Εκχώρηση αθροίσματος συνολικού value(κατευθύνσεων)
		  return (valueCombo + valueCentrality);//Επιστροφή value αθροίσματος κατευθύνσεων και κεντρικότητας
	  }
	  /*Δήλωση και Υλοποίηση της συνάρτησης checkHorizontalValue
	   * Υπολογίζει το value των συνδυασμών που γίνονται οριζόντια π.χ οριζόντια τετράδα,τριάδα κλπ. λαμβάνοντας υπόψη
	   *  τα όρια του πίνακα.
	   * 
	   * 
	   * 
	   * 
	   * 
	   * */
	  int checkHorizontalValue(int x,int y,Board board,int Id){
		  int valueHorizontal = 0;//Δήλωση μεταβλητής που θα έχει το value των οριζόντιων συνδυασμών
		  int horizontalLeft=0,horizontalRight=0;//Δήλωση μεταβλητής με την μορφή flag που υποδηλώνει την ύπαρξη κελιού αντίθετου χρώματος από του Id που του αποκλείει την δυνατότητα συνέχισης συνδυασμού από μια πλευρά.
		  int numHorizontalRight=0,numHorizontalLeft = 0,numHorizontal = 0;//Αθροιστής συνεχόμενων κελιών του χρώματος του Id δεξιά και αριστερά καθώς και ολικά. 
		  int signLeft=100,signRight =100;//Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση του πλησιέστερου κελιού με αντίθετο χρώμα από το κελί που εξετάζουμε.Αντίστοιχα μία από την δεξιά μεριά και μία από την αριστερή.
		  int sizeLeft = 0,sizeRight = 0;//Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση των ορίων του ταμπλό από το κελί που εξετάζουμε.
		  int i = 1;//Δήλωση μίας μεταβλητής που χρησιμεύει στις επαναλήψεις
		  
		  while((i <= 4)&&(i <= x)){//Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε αριστερά από την ευθεία x=0 και να ελέγξουμε μέγιστα 4 κελιά αριστερά από την θέση που εξετάζουμε(π.χ άμα είμαστε στην θέση 2,3 θα μπει 2 φορές στην επανάληψη επειδή βρίσκει δύο κουτιά μέχρι το όριο.)   
		    	//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
			  sizeLeft++;//Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeLeft πόση επιτρεπτή απόσταση έχουμε από αριστερά.
			  i++;
		    }
		  
		  i = 1;//Αρχικοποίηση της μεταβλητής i
		  
		  while((i <= 4)&&(i <= GomokuUtilities.NUMBER_OF_COLUMNS - x - 1)){//Αντίστοιχη διαδικασία με το sizeLeft από δεξιά απλά με όριο την x=14.
		    	sizeRight++;
		    	i++;
		  }
		    
		  i = 1;//Αρχικοποίηση της μεταβλητής i
		  
		  while(i <= sizeLeft){//Επανάληψη που γίνεται μέγιστο sizeLeft φορές.
			  if(Id == board.getTile(x-i,y).getColor()){//Έλεγχος άμα το κελί που είναι αριστερά από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
				  numHorizontalLeft++;//Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας από τα αριστερά.
			  }else if(board.getTile(x-i,y).getColor() == 0){//Έλεγχος άμα το κελί που είναι αριστερά από αυτό που ελέγχουμε έχει γκρι χρώμα.
				  i = 5;//Σε περίπτωση γκρι χρώματος αυξάνουμε τον μετρητή σε μη επιτρεπτή τιμή ώστε να βγει από την επανάληψη,αφού σπάει το σερί του χρώματος μας.
			  }else{//Έλεγχος ύπαρξης αντίθετου χρώματος αριστερά από το κελί που ελέγχουμε.
				  if (numHorizontalLeft!=0){//Έλεγχος άμα ο αριθμός συνεχόμενων κελιών του ίδιου χρώματος με το χρώμα του παίκτη μας είναι μεγαλύτερο-διάφορο του μηδενός.
					  //Ο έλεγχος αυτός γίνεται για να δούμε αμα το ακριβώς αριστερά μας κελί είναι αντίθετου χρώματος.Και ουσιαστικά μας αποκλείει την δυνατότητα συνέχισης συνδυασμού από την αριστερή πλευρά.
					  horizontalLeft=1;//flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα.
				  }
				  signLeft = i;//Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε
				  i = 5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας 
			  }
			  i++; // βήμα 1 για το i
		  }
		  
		  i = 1;//Αρχικοποίηση μεταβλητής i 
		  
		  while((i <= 4)&&(i <= GomokuUtilities.NUMBER_OF_COLUMNS - x - 1)){//Επανάληψη που χρησιμεύει ώστε να μην ξεφύγουμε από την ευθεία χ=14 ( δεξί όριο του πίνακα ) και να ελέγξουμε μέγιστα 4 κελιά δεξιά από τη θέση που εξετάζουμε 
			  if(Id==board.getTile(x+i,y).getColor()){ //Έλεγχος άμα το κελί που είναι δεξιά  από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
				 
				  numHorizontalRight++;  //Αύξηση του αριθμού συνεχόμενων κελιών με ίδιο χρώμα με το δικό μας ( Έλεγχος από δεξιά)
				  
			  }else if(board.getTile(x+i,y).getColor() == 0){//Έλεγχος άμα το κελί που είναι δεξιά από αυτό που ελέγχουμε έχει χρώμα γκρι.
				  
				  i = 5;  // Στην περίπτωση γκρι χρώματος βγαίνουμε από την επανάληψη
			  
			  }else{//Έλεγχος άμα το κελί που είναι δεξιά  από αυτό που ελέγχουμε έχει χρώμα αντίθετο από το δικό μας.
				 
				  if(numHorizontalRight != 0){ ////Έλεγχος άμα ο αριθμός συνεχόμενων κελιών του ίδιου χρώματος με το χρώμα του παίκτη μας είναι μεγαλύτερο-διάφορο του μηδενός.
					//Ο έλεγχος αυτός γίνεται για να δούμε αμα το ακριβώς δεξιά μας κελί είναι αντίθετου χρώματος.
					  horizontalRight=1; //flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα.
					  
				  }
				  
				  signRight = i;  //Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε
				  
				  i = 5;  //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας 
			  }
			  i++;  //βήμα 1 για το i
			  
		  }
		  //Συνολικός οριζόντιος αθροιστής. Μας δίνει το άθροισμα συνεχώμενων κελιών ίδιου χρώματος με το χρώμα του παίκτη μας από τα αριστερά + (και ) από τα δεξία (π.χ πεντάδα , τετράδα κτλπ συνεχώμενων ομόχρομων κελιών)
		  numHorizontal = numHorizontalRight + numHorizontalLeft;
		  //Ξεκινάει το  evaluation 
		 
		  if(numHorizontal >= 4){ // Περίπτωση ύπαρξης 4 ή περισσότερων συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			  valueHorizontal = 100; //Εκχώρηση μέγιστης τιμής στο  value στην περίπτωση αυτή
		  }else if(numHorizontal == 3){ // Περίπτωση ύπαρξης 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά αριστερά και δεξία έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueHorizontal = 90; // Εκχώρηση τιμής 90 στο valueHorizontal
			  if (horizontalLeft==1){ // Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα αριστερά με κελί αντίθετου χρώματος 
				  valueHorizontal=valueHorizontal/3; //Αν η τριάδα  είναι κλειστή από τα αριστερά διαιρούμε το value της με 3
				  }else if (horizontalRight==1){  // Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα δεξιά με κελί αντίθετου χρώματος 
					  valueHorizontal=valueHorizontal/3; // Αν η τριάδα είναι κλειστή από τα δεξιά διαιρούμε το value της με 3
				  }
		  }else if(numHorizontal == 2){ // Περίπτωση ύπαρξης 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			  valueHorizontal = 30;// Εκχώρηση τιμής 30 στο  valueHorizontal
			  if (horizontalLeft==1){ // Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα αριστερά με κελί αντίθετου χρώματος 
				  valueHorizontal=valueHorizontal/3;//Αν η δυάδα  είναι κλειστή από τα αριστερά διαιρούμε το value της με 3
				  }else if (horizontalRight==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα δεξιά με κελί αντίθετου χρώματος 
					  valueHorizontal=valueHorizontal/3;// Αν η δυάδα είναι κλειστή από τα δεξιά διαιρούμε το value της με 3
				  }
		  }else if(numHorizontal == 1){// Περίπτωση ύπαρξης 1  συνεχόμενου κελιού με χρώμα ίδιο με του παίκτη μας
			  valueHorizontal = 6;// Εκχώρηση τιμής 6 στο valueHorizontal
			  if (horizontalLeft==1){ // Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα αριστερά με κελί αντίθετου χρώματος 
				  valueHorizontal=valueHorizontal/3;//Αν το ένα κελί είναι κλειστό από τα αριστερά διαιρούμε το value του με 3
				  }else if (horizontalRight==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από τα δεξιά με κελί αντίθετου χρώματος 
					  valueHorizontal=valueHorizontal/3; // Αν το κελί  κλειστό από τα δεξιά διαιρούμε το value του με 3
				  }
		  }else{ //Περίπτωση μη δυνατότητας συνδυασμού κελιών
			  valueHorizontal = 0; // Εκχώρηση ελάχιστης τιμής στο valueHorizontal
		  }
		  if((signLeft+signRight <= 5)){//Αν η απόσταση του πλησιέστερου από τα αριστερά κελιού αντίθετου χρώματος και του πλησιέστερου από τα δεξιά αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  valueHorizontal = 0; //Εκχώρηση ελάχιστης τιμής στο valueHorizontal
		  }
		  if(signRight + x < 5){ //Αν η απόσταστη του ορίου του πίνακα από τα αριστερά και η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από τα δεξιά αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  valueHorizontal = 0;//Εκχώρηση ελάχιστης τιμής στο valueHorizontal
		  }
		  if(GomokuUtilities.NUMBER_OF_COLUMNS - 1 - x + signLeft < 5){//Αν η απόσταση του ορίου του πίνακα από τα δεξιά και του πλησιέστερου κελιού αντίθετου χρώματος από τα αριστερά είναι μικρότερη ή ίση του 5 (Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  valueHorizontal = 0;//Εκχώρηση ελάχιστης τιμής στο valueHorizontal
		  }
		  
		  
		  return valueHorizontal; // Επιστροφή της valueHorizontal
		  
	  }
	  /*Δήλωση και Υλοποίηση της συνάρτησης checkVerticalValue
	   * Υπολογίζει το value των συνδυασμών που γίνονται κάθετα π.χ κάθετη τετράδα,τριάδα κλπ. λαμβάνοντας υπόψη
	   *  τα όρια του πίνακα.
	   * 
	   * 
	   * 
	   * */
	  
	  int checkVerticalValue(int x,int y,Board board,int Id){
		  int i = 1;//Δήλωση μίας μεταβλητής που χρησιμεύει στις επαναλήψεις
		  int verticalTop=0,verticalDown=0;//Δήλωση μεταβλητής με την μορφή flag που υποδηλώνει την ύπαρξη κελιού αντίθετου χρώματος από του Id που του αποκλείει την δυνατότητα συνέχισης συνδυασμού από πάνω ή προς τα κάτω.
		  int numVerticalDown = 0,numVerticalTop=0,numVertical=0;//Αθροιστής συνεχόμενων κελιών του χρώματος του Id κάτω,πάνω καθώς και ολικά. 
		  int sizeDown = 0,sizeTop=0;//Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση των ορίων του ταμπλό από το κελί που εξετάζουμε.
		  int signTop=100,signDown=100;//Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση του πλησιέστερου κελιού με αντίθετο χρώμα από το κελί που εξετάζουμε.Αντίστοιχα μία από την πάνω και μία από την κάτω πλευρά.
		  int valueVertical = 0;//Δήλωση μεταβλητής που θα έχει το value των κάθετων συνδυασμών.
		  
		  
		  while((i <= 4)&&( i <= y)){//Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε κάτω από την ευθεία y=0 και να ελέγξουμε μέγιστα 4 κελιά κάτω από την θέση που εξετάζουμε.
			//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
			  sizeDown++;//Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeDown πόση επιτρεπτή απόσταση έχουμε από κάτω.
			  i++;//βήμα 1 για το i
		  }
		  
		  i=1;//Αρχικοποίηση της μεταβλητής i
		  
		  while(i<=sizeDown){//Επανάληψη που γίνεται μέγιστο sizeDown φορές.
			  if(Id==board.getTile(x,y-i).getColor()){//Έλεγχος άμα το κελί που είναι κάτω από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
				  numVerticalDown++;//Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας από κάτω.
			  }else if(board.getTile(x, y-i).getColor()==0){//Έλεγχος άμα το κελί που είναι κάτω από αυτό που ελέγχουμε έχει γκρι χρώμα.
				  i	=5;//Σε περίπτωση γκρι χρώματος αυξάνουμε τον μετρητή σε μη επιτρεπτή τιμή ώστε να βγει από την επανάληψη,αφού σπάει το σερί του χρώματος μας.
				  
			  }
			  else{//Έλεγχος άμα το κελί που είναι κάτω από αυτό που ελέγχουμε έχει αντίθετο χρώμα από το δικό μας.
				  verticalDown=1;//flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα κάτω από αυτό που ελέγχουμε.
				  signDown = i;//Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
				  i = 5;//i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας 
			  }
			  i++;//βήμα 1 για το i
		  }
		 
		  i = 1;//Αρχικοποίηση της μεταβλητής i
		  
		  while((i <= 4)&&(i <= GomokuUtilities.NUMBER_OF_ROWS - y - 1)){//Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε πάνω από την ευθεία y=14 και να ελέγξουμε μέγιστα 4 κελιά πάνω από την θέση που εξετάζουμε.
			//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
			  sizeTop++;//Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeTop πόση επιτρεπτή απόσταση έχουμε από πάνω.
			  i++;//βήμα 1 για το i
		  }
		  
		  i=1; //Αρχικοποίηση της μεταβλητής i
		  
		  while(i<=sizeTop){//Επανάληψη που γίνεται μέγιστο sizeTop φορές.
			  if(Id==board.getTile(x,y+i).getColor()){//Έλεγχος άμα το κελί που είναι πάνω από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
				  numVerticalTop++;//Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας από πάνω.
			  }else if(board.getTile(x, y+i).getColor()==0){//Έλεγχος άμα το κελί που είναι πάνω από αυτό που ελέγχουμε έχει γκρι χρώμα.
				  i=5;//Σε περίπτωση γκρι χρώματος αυξάνουμε τον μετρητή σε μη επιτρεπτή τιμή ώστε να βγει από την επανάληψη,αφού σπάει το σερί του χρώματος μας.
			  }
			  else{//Έλεγχος άμα το κελί που είναι πάνω από αυτό που ελέγχουμε έχει αντίθετο χρώμα από το δικό μας.
				  verticalTop=1;//flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα πάνω από αυτό που ελέγχουμε.
				  signTop=i;//Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
				  i = 5;//i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας 
			  }
			  i++;//βήμα 1 για το i
		  }
		  
	//Συνολικός κάθετος αθροιστής. Μας δίνει το άθροισμα συνεχώμενων κελιών ίδιου χρώματος με το χρώμα του παίκτη μας από πάνω + (και ) από κάτω (π.χ πεντάδα , τετράδα κτλπ συνεχώμενων ομόχρομων κελιών)
		numVertical=numVerticalTop+numVerticalDown;  
		 //Ξεκινάει το  evaluation 
		
		  if(numVertical >= 4){// Περίπτωση ύπαρξης 4 ή περισσότερων συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			  valueVertical = 100; //Εκχώρηση μέγιστης τιμής στο  value στην περίπτωση αυτή
		  }else if(numVertical == 3){ // Περίπτωση ύπαρξης 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά πάνω και κάτω έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueVertical = 90;// Εκχώρηση τιμής 90 στο valueVertical
			  if (verticalTop==1){// Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω με κελί αντίθετου χρώματος 
				  valueVertical=valueVertical/3;//Αν η τριάδα  είναι κλειστή από πάνω διαιρούμε το value της με 3
				  }else if (verticalDown==1){// Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω με κελί αντίθετου χρώματος 
					  valueVertical=valueVertical/3;//Αν η τριάδα  είναι κλειστή από πάνω διαιρούμε το value της με 3
				  }
		  }else if(numVertical == 2){// Περίπτωση ύπαρξης 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			  valueVertical = 30;// Εκχώρηση τιμής 30 στο valueVertical
			  if (verticalTop==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω με κελί αντίθετου χρώματος 
				  valueVertical=valueVertical/3;//Αν η δυάδα  είναι κλειστή από πάνω διαιρούμε το value της με 3
				  }else if (verticalDown==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω με κελί αντίθετου χρώματος 
					  valueVertical=valueVertical/3;//Αν η δυάδα  είναι κλειστή από κάτω διαιρούμε το value της με 3
				  }
		  }else if(numVertical == 1){// Περίπτωση ύπαρξης 1  συνεχόμενου κελιού με χρώμα ίδιο με του παίκτη μας
			  valueVertical = 6;// Εκχώρηση τιμής 6 στο valueVertical
			  if (verticalTop==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω με κελί αντίθετου χρώματος 
				  valueVertical=valueVertical/3;//Αν το ένα κελί είναι κλειστό από τα πάνω διαιρούμε το value του με 3
				  }else if (verticalDown==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω με κελί αντίθετου χρώματος 
					  valueVertical=valueVertical/3;//Αν το ένα κελί είναι κλειστό από κάτω διαιρούμε το value του με 3
				  }
		  }else{//Περίπτωση μη δυνατότητας συνδυασμού κελιών
			  valueVertical = 0;// Εκχώρηση ελάχιστης τιμής στο valueHorizontal
		  }
		  
		  if((signDown+signTop<=5)){//Αν η απόσταση του πλησιέστερου από πάνω κελιού αντίθετου χρώματος και του πλησιέστερου από κάτω αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  
			  valueVertical=0;// Εκχώρηση ελάχιστης τιμής στο valueHorizontal
			  
		  }
		  if(signTop + y < 5){//Αν η απόσταστη του ορίου του πίνακα από κάτω και η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από πάνω αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  
			  valueVertical = 0;// Εκχώρηση ελάχιστης τιμής στο valueHorizontal
			  
		  }
		  if(GomokuUtilities.NUMBER_OF_ROWS - 1 - y + signDown < 5){//Αν η απόσταση του ορίου του πίνακα από πάνω και του πλησιέστερου κελιού αντίθετου χρώματος από κάτω είναι μικρότερη ή ίση του 5 (Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			  
			 valueVertical = 0; // Εκχώρηση ελάχιστης τιμής στο valueHorizontal
			 
		  }
		  
		  return valueVertical;// Επιστροφή της valueVertical
	  }
	  
	  
	  /*Δήλωση και Υλοποίηση της συνάρτησης checkDiagonaValue1
	   * Υπολογίζει το value των συνδυασμών που γίνονται στην πρώτη διαγώνιο (y=-x+c) π.χ κάθετη τετράδα,τριάδα κλπ. λαμβάνοντας υπόψη
	   *  τα όρια του πίνακα.
	   * 
	   * 
	   * 
	   * */
	  
	  int checkDiagonalValue1(int x,int y,Board board,int Id){
		  int diagonal1Down = 0,diagonal1Top = 0; //Δήλωση μεταβλητής με την μορφή flag που υποδηλώνει την ύπαρξη κελιού αντίθετου χρώματος από του Id που του αποκλείει την δυνατότητα συνέχισης συνδυασμού από πάνω αριστερά  ή προς τα κάτω δεξιά.
		  int numDiagonal1 = 0,numDiagonal1Top = 0,numDiagonal1Down = 0;//Αθροιστής συνεχόμενων κελιών του χρώματος του Id κάτω δεξιά ,πάνω αριστερά καθώς και ολικά. 
		  int signDiagonal1Down=100,signDiagonal1Top=100; //Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση του πλησιέστερου κελιού με αντίθετο χρώμα από το κελί που εξετάζουμε.Αντίστοιχα μία από την πάνω αριστερά και μία από την κάτω δεξιά πλευρά.
		  int valueDiagonal1 = 0; //Δήλωση μεταβλητής που θα έχει το value των διαγώνιων (y=-x+c) συνδυασμών.
		  int sizeDiagonal1Down = 0,sizeDiagonal1Top = 0;//Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση των ορίων του ταμπλό από το κελί που εξετάζουμε.
		  int i = 1; //Δήλωση μιας μεταβλητής που χρησιμεύει στις επαναλήψεις
		  
		  int sumColRow = GomokuUtilities.NUMBER_OF_COLUMNS-1 + GomokuUtilities.NUMBER_OF_ROWS - 1; //Άθροισμα διαστάσεων πίνακα -2 (28)
		  
		  while((i<=4)&&(y-i>=0)&&(x+i<=GomokuUtilities.NUMBER_OF_COLUMNS-1)){//Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε κάτω από την ευθεία y=0 ,δεξιά από την x=14 και να ελέγξουμε μέγιστα 4 κελιά κάτω δεξιά από την θέση που εξετάζουμε.
				//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
			  sizeDiagonal1Down++;//Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeDiagonal1Down πόση επιτρεπτή απόσταση έχουμε από κάτω δεξιά.
			  i++; //Βήμα 1 για το i
		  }
		  
		  i=1; //Αρχικοποίηση της μεταβλητής i
		  
		  if((y+x>=4)&&(y+x < sumColRow - 3)){//Διαγώνιες που σχηματίζουν πεντάδα σε είδη ευθειών y = -x + c (αποκλείει ουσιαστικά αυτές που δεν σχηματίζουν)
			  while(i<=sizeDiagonal1Down){//Επανάληψη που γίνεται μέγιστο sizeDiagona1Down φορές.
				  if(Id==board.getTile(x+i,y-i).getColor()){//Έλεγχος άμα το κελί που είναι κάτω δεξιά από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					  numDiagonal1Down++;  //Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας προς τα κάτω δεξιά
				  }else if (board.getTile(x+i, y-i).getColor()==0){//Έλεγχος άμα το κελί που είναι κάτω δεξιά από αυτό που ελέγχουμε έχει γκρι χρώμα.
					  i=5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση γκρι χρώματος.
				  }
				  else{//Έλεγχος άμα το κελί που είναι πάνω από αυτό που ελέγχουμε έχει χρώμα αντίθετο από το δικό μας.
					  diagonal1Down=1;  //flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα κάτω δεξιά από αυτό που ελέγχουμε.
					  signDiagonal1Down=i;  //Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
					  i=5;  //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας
				  } 
				  i++;	   //Βήμα 1 για το i
			  }
			  
			i = 1;  //Αρχικοποίηση της μεταβλητής i
		  
			while ((i<=4)&&(x-i>=0)&&(y+i<=GomokuUtilities.NUMBER_OF_COLUMNS-1)){//Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε πάνω από την ευθεία y=14 ,αριστερά από την x=0 και να ελέγξουμε μέγιστα 4 κελιά πάνω αριστερά από την θέση που εξετάζουμε.
				//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
				sizeDiagonal1Top++; //Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeDiagonal1Top πόση επιτρεπτή απόσταση έχουμε από πάνω αριστερά.
				i++;  //Βήμα 1 για το i
			}
			i=1;  //Αρχικοποίηση της μεταβλητής i
			while (i<=sizeDiagonal1Top){//Επανάληψη που γίνεται μέγιστο sizeDiagonal1Top φορές.
				if(Id==board.getTile(x-i,y+i).getColor()){//Έλεγχος άμα το κελί που είναι πάνω αριστερά  από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					numDiagonal1Top++;//Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας προς τα πάνω αριστερά 
				}else if(board.getTile(x-i, y+i).getColor()==0){//Έλεγχος άμα το κελί που είναι πάνω αριστερά  από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					i=5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση γκρι χρώματος
				}
				else {//Έλεγχος άμα το κελί που είναι πάνω από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					diagonal1Top=1;  //flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα πάνω αριστερά από αυτό που ελέγχουμε.
					signDiagonal1Top=i;  //Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
					i=5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας
				}
				
				i++;  //Βήμα 1 για το i
			}
		 }
		  //Εκχώρηση αθροίσματος συνεχόμενων κελιών προς τα πάνω αριστερά και προς τα κάτω δεξιά σε μία ολική μεταβλητή
		  numDiagonal1=numDiagonal1Top+numDiagonal1Down;
		  
		  if (numDiagonal1>=4){// Περίπτωση ύπαρξης 4 ή περισσότερων συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			  valueDiagonal1=100; //Εκχώρηση μέγιστης τιμής στο  value στην περίπτωση αυτή
		  }else if(numDiagonal1==3){// Περίπτωση ύπαρξης 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά διαγωνίως (y=-x+c) έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueDiagonal1=90;// Εκχώρηση τιμής 90 στο valueDiagonal1
			  if (diagonal1Top==1){  // Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω αριστερά  με κελί αντίθετου χρώματος 
				  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από πάνω αριστερά διαιρούμε το value του με 3
				  }else if (diagonal1Down==1){// Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω δεξιά με κελί αντίθετου χρώματος 
					  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από κάτω δεξιά διαιρούμε το value του με 3
				  }
		  }else if(numDiagonal1==2){// Περίπτωση ύπαρξης 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά διαγωνίως (y=-x+c) έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueDiagonal1=30; // Εκχώρηση τιμής 30 στο valueDiagonal1
			  if (diagonal1Top==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω αριστερά με κελί αντίθετου χρώματος 
				  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από τα πάνω αριστερά  διαιρούμε το value του με 3
				  }else if (diagonal1Down==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω δεξιά με κελί αντίθετου χρώματος 
					  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από τα κάτω αριστερά διαιρούμε το value του με 3
				  }
		  }else if(numDiagonal1==1){// Περίπτωση ύπαρξης 1 κελιού με χρώμα ίδιο με του παίκτη μας το οποίο διαγωνίως (y=-x+c) έχει γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueDiagonal1=6;// Εκχώρηση τιμής 6 στο valueDiagonal1
			  if (diagonal1Top==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω αριστερά με κελί αντίθετου χρώματος 
				  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από τα πάνω αριστερά διαιρούμε το value του με 3
				  }else if (diagonal1Down==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω δεξιά με κελί αντίθετου χρώματος 
					  valueDiagonal1=valueDiagonal1/3; //Αν το ένα κελί είναι κλειστό από τα κάτω δεξιά διαιρούμε το value του με 3
				  }
		  }else{ //Περίπτωση μη δυνατότητας συνδυασμού κελιών
			  valueDiagonal1 =0; // Εκχώρηση ελάχιστης τιμής στο valueDiagonal1
		  }
		    if ((signDiagonal1Down+signDiagonal1Top<=5)){//Αν η απόσταση του πλησιέστερου από πάνω αριστερά κελιού αντίθετου χρώματος και του πλησιέστερου από κάτω δεξιά αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)  
		    	valueDiagonal1=0;// Εκχώρηση ελάχιστης τιμής στο valueDiagonal1
		    }
		    if(( x + signDiagonal1Down < 5 )||(GomokuUtilities.NUMBER_OF_ROWS - 1 - y + signDiagonal1Down < 5)){//Αν οι αποστάσεις του ορίου του πίνακα από πάνω διαγωνίως και η απόσταση του ορίου του πίνακα από αριστερά διαγωνίως είναι μικρότερες του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
		    	valueDiagonal1 = 0 ;// Εκχώρηση ελάχιστης τιμής στο valueDiagonal1
		    }
		    if((y + signDiagonal1Top < 5)||(GomokuUtilities.NUMBER_OF_ROWS - 1 - x + signDiagonal1Top < 5)){//Αν οι αποστάσεις  του ορίου του πίνακα από κάτω διαγωνίως και η απόσταση του ορίου του πίνακα από δεξιά διαγωνίως είναι μικρότερες του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
		    	valueDiagonal1 = 0 ;// Εκχώρηση ελάχιστης τιμής στο valueDiagonal1
		    }
		    return valueDiagonal1;  //Επιστροφή της ValueDiagonal1
	  }
	  
	  /*Δήλωση και Υλοποίηση της συνάρτησης checkDiagonaValue2
	   * Υπολογίζει το value των συνδυασμών που γίνονται στην δεύτερη διαγώνιο (y=x+c) π.χ κάθετη τετράδα,τριάδα κλπ. λαμβάνοντας υπόψη
	   *  τα όρια του πίνακα.
	   * 
	   * 
	   * 
	   * */
	 int checkDiagonalValue2(int x,int y,Board board,int Id){
		 
		 int diagonal2Down = 0, diagonal2Top = 0; //Δήλωση μεταβλητής με την μορφή flag που υποδηλώνει την ύπαρξη κελιού αντίθετου χρώματος από του Id που του αποκλείει την δυνατότητα συνέχισης συνδυασμού από πάνω δεξιά ή προς τα κάτω αριστερά.
		 int signDiagonal2Top = 100, signDiagonal2Down = 100; //Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση του πλησιέστερου κελιού με αντίθετο χρώμα από το κελί που εξετάζουμε.Αντίστοιχα μία από την πάνω δεξιά και μία από την κάτω αριστερά πλευρά.
		 int valueDiagonal2 = 0; //Δήλωση μεταβλητής που θα έχει το value των διαγώνιων (y=x+c) συνδυασμών.
		 int sizeDiagonal2Down = 0, sizeDiagonal2Top = 0; //Δήλωση μεταβλητής στην οποία αποθηκεύουμε την απόσταση των ορίων του ταμπλό από το κελί που εξετάζουμε.
		 int  i = 1; //Δήλωση μιας μεταβλητής που χρησιμεύει στις επαναλήψεις
		 int numDiagonal2 = 0, numDiagonal2Top = 0, numDiagonal2Down = 0; //Αθροιστής συνεχόμενων κελιών του χρώματος του Id κάτω αριστερά ,πάνω δεξιά καθώς και ολικά. 
		 
		 while((i<=4)&&(y-i>=0)&&(x-i>=0)){ //Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε κάτω από την ευθεία y=0 ,αριστερά από την x=0 και να ελέγξουμε μέγιστα 4 κελιά κάτω αριστερά από την θέση που εξετάζουμε.
			//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
			 sizeDiagonal2Down++; //Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeDiagonal2Down πόση επιτρεπτή απόσταση έχουμε από κάτω αριστερά.
			 i++; //Βήμα 1 για το i
		 }
		 
		 i=1;//Αρχικοποίηση της μεταβλητής i
		 
		 if ((x-y<GomokuUtilities.NUMBER_OF_COLUMNS-4)&&(y-x<GomokuUtilities.NUMBER_OF_COLUMNS-4)){ //Διαγώνιες που σχηματίζουν πεντάδα σε είδη ευθειών y = x + c (Αποκλείει αυτές που δεν σχηματίζουν)
			 while (i <= sizeDiagonal2Down){//Επανάληψη που γίνεται μέγιστο sizeDiagona2Down φορές.
				 if(Id==board.getTile(x-i,y-i).getColor()){//Έλεγχος άμα το κελί που είναι κάτω αριστερά από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					 numDiagonal2Down++; //Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας προς τα κάτω αριστερά.
				 }else if(board.getTile(x-i,y-i).getColor() ==0 ){//Έλεγχος άμα το κελί που είναι κάτω αριστερά  από αυτό που ελέγχουμε έχει χρώμα αντίθετο με το δικό μας.
					 i = 5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση γκρι χρώματος
				 }else{//Έλεγχος άμα το κελί που είναι κάτω αριστερά  από αυτό που ελέγχουμε έχει γκρι χρώμα.
					 diagonal2Down=1;  //flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα κάτω αριστερά από αυτό που ελέγχουμε.
					 signDiagonal2Down = i;//Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
					 	i = 5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας
					  }
				 i++;//Βήμα 1 για το i
			 } 
			 
			 i = 1;//Αρχικοποίηση της μεταβλητής i
			 
			 while((i<=4)&&(x+i<=GomokuUtilities.NUMBER_OF_COLUMNS-1)&&(y+i<=GomokuUtilities.NUMBER_OF_COLUMNS-1)){ //Επανάληψη που χρησιμεύει στο να μην ξεφύγουμε πάνω από την ευθεία y=14 ,δεξιά από την x=14 και να ελέγξουμε μέγιστα 4 κελιά πάνω δεξιά από την θέση που εξετάζουμε.
				//Με το i<=4 ουσιαστικά ελέγχουμε σε ακτίνα 4 κελιών γιατί αυτά σχηματίζουν πεντάδα με το κελί που ελέγχουμε.
				 sizeDiagonal2Top++; //Όσες φορές μπαίνει στην επανάληψη μας λέει η μεταβλητή sizeDiagonal2Top πόση επιτρεπτή απόσταση έχουμε από πάνω δεξιά.
				 i++;//Βήμα 1 για το i
			 }
			 

			i = 1;//Αρχικοποίηση της μεταβλητής i
			
			 while (i <= sizeDiagonal2Top){ //Επανάληψη που γίνεται μέγιστο sizeDiagonal2Top φορές.
				 if(Id==board.getTile(x+i,y+i).getColor()){//Έλεγχος άμα το κελί που είναι πάνω δεξιά  από αυτό που ελέγχουμε έχει χρώμα ίδιο με το δικό μας.
					 numDiagonal2Top++; //Αύξηση της μεταβλητής ώστε να δούμε τον αριθμό των συνεχόμενων κελιών που έχουν το χρώμα μας προς τα πάνω δεξιά.
				 }else if(board.getTile(x+i,y+i).getColor()==0){//Έλεγχος άμα το κελί που είναι πάνω δεξιά  από αυτό που ελέγχουμε έχει χρώμα αντίθετο με το δικό μας.
					 i = 5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση γκρι χρώματος
				 }else{ //Έλεγχος άμα το κελί που είναι πάνω δεξιά από αυτό που ελέγχουμε έχει γκρι χρώμα.
					 diagonal2Top=1;  //flag = 1 ουσιαστικά μας λέει ότι υπάρχει κελί με αντίθετο χρώμα πάνω δεξιά από αυτό που ελέγχουμε.
					 signDiagonal2Top = i; //Μεταβλητή στην οποία αποθηκεύεται η απόσταση του πλησιέστερου κελιού αντίθετου χρώματος από την θέση που ελέγχουμε.
					 i=5; //i=5 για να βγούμε από την επανάληψη σε περίπτωση αντίθετου χρώματος από το δικό μας
				 }
				 i++;//Βήμα 1 για το i
				}
			}
		  //Εκχώρηση αθροίσματος συνεχόμενων κελιών προς τα πάνω δεξιά και προς τα κάτω αριστερά σε μία ολική μεταβλητή
		 numDiagonal2=numDiagonal2Down+numDiagonal2Top;
		 
		 if (numDiagonal2>=4){// Περίπτωση ύπαρξης 4 ή περισσότερων συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας
			 valueDiagonal2=100; //Εκχώρηση μέγιστης τιμής στο  value στην περίπτωση αυτή
		 }else if(numDiagonal2==3){//Περίπτωση ύπαρξης 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά διαγωνίως (y=x+c) έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			 valueDiagonal2=90;// Εκχώρηση τιμής 90 στο valueDiagonal2
			 if (diagonal2Top==1){// Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω δεξιά  με κελί αντίθετου χρώματος 
				 valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από πάνω δεξιά διαιρούμε το value του με 3
			 }else if (diagonal2Down==1){// Περίπτωση 3 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω αριστερά  με κελί αντίθετου χρώματος 
				 valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από κάτω αριστερά διαιρούμε το value του με 3
			 }
		  }else if(numDiagonal2==2){//Περίπτωση ύπαρξης 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτη μας τα οποιά διαγωνίως (y=x+c) έχουν γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueDiagonal2=30;// Εκχώρηση τιμής 30 στο valueDiagonal2
			  if (diagonal2Top==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω δεξιά με κελί αντίθετου χρώματος 
				  valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από τα πάνω δεξιά διαιρούμε το value του με 3
			  }else if (diagonal2Down==1){// Περίπτωση 2 συνεχόμενων κελιών με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω αριστερά  με κελί αντίθετου χρώματος 
				  valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από τα κάτω αριστερά διαιρούμε το value του με 3
			  }
		  }else if(numDiagonal2==1){// Περίπτωση ύπαρξης 1 κελιού με χρώμα ίδιο με του παίκτη μας το οποίο διαγωνίως (y=x+c) έχει γκρι κελιά και όχι κελιά αντίθετου χρώματος ( Δεν μπλοκάρονται άρα θα έχουν μεγαλύτερο  value)
			  valueDiagonal2=6;// Εκχώρηση τιμής 6 στο valueDiagonal2
			  if (diagonal2Top==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από πάνω δεξιά με κελί αντίθετου χρώματος 
				  valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από τα πάνω δεξιά διαιρούμε το value του με 3  
			  }else if (diagonal2Down==1){// Περίπτωση 1 κελιού με χρώμα ίδιο με του παίκτης μας που μπλοκάρεται όμως αυτή τη φορά από κάτω αριστερά με κελί αντίθετου χρώματος 
					  valueDiagonal2=valueDiagonal2/3; //Αν το ένα κελί είναι κλειστό από τα κάτω αριστερά διαιρούμε το value του με 3
			  }
		  }else{ //Περίπτωση μη δυνατότητας συνδυασμού κελιών
			  valueDiagonal2=0; // Εκχώρηση ελάχιστης τιμής στο valueDiagonal2
		  }
		 if(((signDiagonal2Down+signDiagonal2Top) <=5)){//Αν η απόσταση του πλησιέστερου από πάνω δεξιά κελιού αντίθετου χρώματος και του πλησιέστερου από κάτω αριστερά αθροιστικά είναι μικρότερη ή ίση του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			 valueDiagonal2 = 0; // Εκχώρηση ελάχιστης τιμής στο valueDiagonal2
		 }
		 if(( GomokuUtilities.NUMBER_OF_ROWS -1 - x + signDiagonal2Down < 5 )||(GomokuUtilities.NUMBER_OF_ROWS - 1 - y + signDiagonal2Down < 5)){//Αν οι αποστάσεις του ορίου του πίνακα από πάνω διαγωνίως και η απόσταση του ορίου του πίνακα από δεξιά διαγωνίως είναι μικρότερες του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			 valueDiagonal2 = 0 ; // Εκχώρηση ελάχιστης τιμής στο valueDiagonal2
		 }
		 if((y + signDiagonal2Top < 5)||( x + signDiagonal2Top < 5)){//Αν οι αποστάσεις του ορίου του πίνακα από κάτω διαγωνίως και η απόσταση του ορίου του πίνακα από αριστερά διαγωνίως είναι μικρότερες του 5(Ουσιαστικά δεν υπάρχει αρκετός χώρος για να σχηματίσουμε πεντάδα)
			 valueDiagonal2 = 0 ; // Εκχώρηση ελάχιστης τιμής στο valueDiagonal2
		 }
		  return valueDiagonal2; //Επιστροφή της ValueDiagonal2
	  }
	  
	 
}
